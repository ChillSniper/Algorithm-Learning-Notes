# 2024年冬季 数据结构课程笔记

## Lecture 22 线性结构查找

### 顺序查找

无序表采用顺序查找，时间复杂度为$O(n)$

### 对半查找

实际上，对于二分查找，代码的关键在于确定区间的边界下标

对半插入排序可以将每次插入时的关键词比较次数降为$O(logn)$
总体时间复杂度仍为$O(n ^ 2)$

对于同一序列分别使用**对半插入排序**和**直接插入排序**，可能不同的点在于**元素的比较次数**

对于分析对半查找算法的时间复杂度，引入**二叉判定树**
实际上是使用了**扩充二叉树**

#### **Average Search Length** 平均查找长度

查找成功的平均查找长度为内节点的深度$\times$所在层个数，再取平均值

查找失败的平均查找长度为外节点的深度$\times$所在层个数，再取平均值

### 斐波那契查找

$k$阶斐波那契查找的时间复杂度为$O(log_2{n})$

说实话这块没怎么搞懂，等后面再看

### 插值查找

插值查找实际上适用于有序数组中元素**均匀**随机分布的情况

算法对应代码如下

```cpp
int InterpolartionSearch(int arr[], int n, int K){
    int l = 1, r = n, mid;
    while (arr[l] <= K && arr[r] >= K && l <= r)
    {
        // the essence
        // (mid - l) / (r - l) = (k - arr[l]) / (arr[r] - arr[l])
        mid = (K - arr[l]) * (r - l) / (arr[r] - arr[l]);
        if(arr[mid] == K) return mid;
        else if(arr[mid] > K) l = mid + 1;
        else r = mid - 1;
    }
    return -1;
}
```

插值查找平均时间复杂度为$O(log{logn})$，最坏时间复杂度为$O(n)$

### 分块查找

跳过

### 对半查找 细究

增加返回元素的包含信息
返回：$\ge k$的第一个位置， $\le k$的最后一个位置
此处的问题即在于，在二分时如何判定$k = R[mid]$后，对于$low$和$high$的边界确定的取舍？

解决问题的根本在于，如果说要找第一个位置，那就让查询区间$[low, high]$往左靠，如果说要找最后一个位置，那就让查询区间$[low, high]$往右靠

## Lecture 23 二叉查找树

### 二叉查找树 详情

注意到有序数组的二分查找适用于**静态**查找情形，而动态查找则需要使用到**二叉查找树**。
目的是将**插入、删除、查找**时间优化至$O(log{n})$

注意二叉判定树并不是二叉查找树，二叉查找树已经将数据**真正地**放入了二叉树中！

#### 查找算法的递归版本

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root) return nullptr;
        if(root->val == val) return root;
        if(root->val > val) return searchBST(root->left, val);
        return searchBST(root->right, val);
    }
};
```

#### 插入算法

算法实现代码如下

```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(!root){
            root = new TreeNode(val);
            return root;
        }
        if(root->val == val) return root;
        if(root->val < val){
            if(!root->right){
                root->right = new TreeNode(val);
                return root;
            } else insertIntoBST(root->right, val);
        } else {
            if(!root->left){
                root->left = new TreeNode(val);
                return root;
            } else insertIntoBST(root->left, val);
        }
        return root;
    }
};
```

注意二叉查找树中关于根指针的**引用参数**操作

#### 删除算法

本质上，是要明白删除算法的步骤所在。注意到当删除节点有两个子节点时，需要在右子树中寻找到值最小者，并且与根节点替换，**然后删除该最小节点**。实际上，是一个递归调用的过程。

算法对应代码如下

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        Delete(root, key);
        return root;
    }
    void Delete(TreeNode* &root, int k){
        if(!root) return ;
        if(root->val < k) Delete(root->right, k);
        else if(root->val > k) Delete(root->left, k);
        else if(root->left && root->right){
            TreeNode* p = root->right;
            while(p->left) p = p->left;
            root->val = p->val;
            Delete(root->right, p->val);
        }
        else{
            TreeNode* p = root;
            root = (root->left) ? root->left : root->right;
            delete p; p = nullptr;
        }
    }
};
```

注意代码中对根指针作为**引用参数**情形的操作！

#### 二叉查找树的可能个数

实际上，即为$Catalan$数，涉及到进栈出栈问题
满足$$\Large Catalan(n) = \frac{1}{n + 1}\times C_{2n}^{n}$$

使用递推关系求解，而$Catalan(n)$的推导过程涉及到动态规划

#### 对于二叉查找树的总结

关于二叉查找树，查找、插入、删除的平均时间复杂度为$O(logn)$，但是特别注意！**最坏时间复杂度为$O(n)$**

### 高度平衡树

亦称$AVL$树

$AVL$树中平衡系数定义为对于任意节点$p$的左子树减去右子树高度

注意到对于高度为$h$，包含$n$个节点的高度平衡树，其高度满足$$h \le 2\times logn$$

对于高度平衡树的插入和删除操作，可能会破坏$AVL$树的平衡性，由此，要执行**旋转**操作

#### 高度平衡树的插入操作

有四种情况：$LL/RR$, $LR/RL$型

对于$LL/RR$，采用**单旋转**插入
首先寻找**第一个**非平衡点，然后包含第一个非平衡点在内的往下祖孙三代节点，然后将中间的那个节点作为根节点，并对部分子树进行移动

注意这个**第一个**指的是在向上搜索的过程中遇到的**第一个**不平衡的节点

对于$LR/RL$，采用**双旋转**操作
这种情况下，先将**折线变成直线**，然后再执行一次右转（对于$LR$型）$or$左转
也就是说，要执行总共两次旋转

### 红黑树

此处PPT设计内容很少，待假期补充

一种更特殊的**二叉查找树**
节点为红色或者黑色
**根节点、外节点**为黑色

注意**红父黑子**
任意节点到外节点的路径上，包含的黑色节点数目相同，即**黑高相等**

### 伸展树（$Splay$树）

不严格限制查找树的形状，追求整体的访问效率
各种操作的均摊时间复杂度为$O(logn)$

注意在伸展树中，对于数据元素的操纵是出于**时间局部性**假设的考量，也就是说，刚被访问的节点可能会很快又被访问，因此要把刚访问的节点放到靠近根节点的地方

实际上，每次访问节点$X$的目标是将$X$调到树的**根部**

对于节点的三种操作情况
对于节点记录为当前节点$x$，父节点$p$，爷爷节点$g$

$LR/RL$型
操作和$AVL$树中的$LR/RL$型一致
两次均以$x$为轴进行旋转

$LL/RR$型
先以$p$为轴，再以$x$为轴进行旋转

没有爷节点的类型
此时仅以$x$为轴进行旋转即可

## Lecture 24 多叉查找树

### $B$树

树形查找方法属于**内查找**方法，适用于检索文件能完整放入计算机内存中的情况。

当查找树节点储存在外存时，指针域的值是**磁盘存储器**的地址

由于外存访问次数依赖于查找树高度，因此查找树高度应当尽可能的**矮**

由此，使用到**多叉查找树**

$B$树是平衡$m$叉查找树

注意$m$阶$B$树的定义

其中有两点很重要
有$k$个孩子的节点**恰好**包含$k - 1$个递增有效的关键词
所有的叶节点**均在同一层**，不包含任何信息

特别注意到**叶节点**是虚拟节点，相当于外节点，不含数据！！！

对于$B$树的操作

#### 插入

对于插入操作，首先要查找节点，查找失败则插入
查找使用递归方法

特别注意到，在节点中插入关键词之后，如果包含关键词数量超过$m - 1$个，则需要对当前节点值进行**上溢**，需要执行**分裂**操作

也就是说，$m$阶$B$树每个节点最多包含$m - 1$个关键词！

对于分裂，有可能分裂操作会一直传递到根节点

#### 删除

注意到删除操作需要使用到下溢、借位

$m$阶$B$树的**非根节点**在删除操作执行后至少需要$\Large\lceil \frac{m}{2}\rceil - 1$个节点！！！

注意到删除操作，如果当前节点在删除关键词之后节点数$<  \lceil \frac{m}{2}\rceil - 1$，那么需要从左右兄弟节点中借关键词

注意借节点不是直接从左右兄弟节点中借，而是通过父节点进行中转

借的顺序是左顾右盼，即先借左边的

如果说不够借，那么就合并节点；如果说合并导致了上层节点下溢，那么继续“借”或者合并

注意$P50$中就采取了合并节点的操作，在第二步到第三步的操作中

合并情况可能最终会延续到根节点

同时，特别注意到，所有**叶节点**都在**同一层**！！！

注意到，当借位不是发生在最底层时，从左右兄弟节点中借最大（最小）关键词时，**必须**连同兄弟节点的**最右（左）子树**一起借！！！

假设叶节点在第$k$层，那么满足$$\Large k \le 1 + log_{\lceil\frac{m}{2}\rceil}^{(\frac{n + 1}{2})}$$
即时间复杂度为$O(log_m^{n})$

### $B+$树

$B$树每个节点存储关键词以及对应的数据记录，而$B+$树仅仅存储关键词

注意与$B$树不同的是，$B+$树包含有$n$个孩子的节点有$n$个关键词！！！（而不是$n - 1$！）

非叶节点仅包含各孩子的最大关键词以及指向孩子的指针，不包含实际的数据记录

而所有叶节点包含全部关键词以及指向相应数据记录的指针

### 数字查找树 / 字典树

实际上就是$Trie$树
